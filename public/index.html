<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<!--Começo do Material Design Lite-->
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.teal-red.min.css">
<script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
<!--Fim do Material Design Lite-->
<!-- Começo do jquery-->
<script
    src="http://code.jquery.com/jquery-3.2.1.min.js"
    integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
    crossorigin="anonymous"></script>
<!-- Fim do jquery-->
<script type="text/javascript" src="opengl.js"></script>
<script type="text/javascript">
    var GlobalSquare = undefined;
    var projectionMatrix, modelViewMatrix;
    function initMatrices() {
        // The transform matrix for the square - translate back in Z for the camera
        modelViewMatrix = new Float32Array(
            [1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, -3.333, 1]);

        // The projection matrix (for a 45 degree field of view)
        projectionMatrix = new Float32Array(
            [2.41421, 0, 0, 0,
                0, 2.41421, 0, 0,
                0, 0, -1.002002, -1,
                0, 0, -0.2002002, 0]);

    }
    // não renderiza o coisa n sei pq
    function createSquare(gl) {
        //Pede o arquivo que define meu objeto. Isso é uma operação assincrona,
        //como todos os IOs em js
        var result = fetch('http://localhost:8080/testeObjeto.json')
            .then(response => {//Resolve ou rejeita a promessa de carga que foi feita
                if (response.status === 200 || response.status === 0) {
                    return Promise.resolve(response);
                } else {
                    return Promise.reject(new Error(response.statusText));
                }
            })
            .then(response => {//Resposta é um json pro próximo método.
                return response.json();
            })
            .then(function (data) {
                //Aqui eu já tenho o json
                var vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                var testeArr1 = new Float32Array(data.geometry);
                gl.bufferData(gl.ARRAY_BUFFER, testeArr1, gl.STATIC_DRAW);

                var colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                var testeArr2 = new Float32Array(data.color);
                gl.bufferData(gl.ARRAY_BUFFER, testeArr2, gl.STATIC_DRAW);

                var shaderProgram = initShader(gl, vertexShaderSource, fragmentShaderSource);
                //Ponteiros para os parâmetros do shader
                var shaderVertexPositionAttribute = gl.getAttribLocation(shaderProgram, "vertexPos");
                gl.enableVertexAttribArray(shaderVertexPositionAttribute);
                var shaderVertexColorAttribute = gl.getAttribLocation(shaderProgram, "vertexColor");
                gl.enableVertexAttribArray(shaderVertexColorAttribute);
                var shaderProjectionMatrixUniform = gl.getUniformLocation(shaderProgram, "projectionMatrix");
                var shaderModelViewMatrixUniform = gl.getUniformLocation(shaderProgram, "modelViewMatrix");

                var square = {
                    buffer: vertexBuffer,
                    cBuffer: colorBuffer,
                    vertSize: data.vertexSize,
                    nVerts: data.numVertices,
                    primtype: gl.TRIANGLES,
                    shaderProgram: shaderProgram,
                    shaderVertexPositionAttribute: shaderVertexPositionAttribute,
                    shaderVertexColorAttribute: shaderVertexColorAttribute,
                    shaderProjectionMatrixUniform : shaderProjectionMatrixUniform,
                    shaderModelViewMatrixUniform:shaderModelViewMatrixUniform
                };

                GlobalSquare = square;
                return square;
            })
            .catch(function (error) {
                    alert(error);
                }
            );

    }
    var vertexShaderSource =
        " precision highp float;\n" +
            "    attribute vec3 vertexPos;\n" +
            "    attribute vec4 vertexColor;\n"+
            "    uniform mat4 modelViewMatrix;\n" +
            "    uniform mat4 projectionMatrix;\n" +
            "    varying vec4 vColor;\n"+
            "    void main(void) {\n" +
            "        vColor = vertexColor;\n"+
            "        gl_Position = projectionMatrix * modelViewMatrix * \n" +
            "            vec4(vertexPos, 1.0);\n" +
            "    }\n";
    var fragmentShaderSource =
        " precision highp float;\n" +
            "varying vec4 vColor;\n"+
            "void main(void) {\n" +
            "    // Return the pixel color: always output white\n" +
            "    gl_FragColor = vColor;\n" +
            "}\n";

    function draw(gl, obj) {
        if (GlobalSquare) {
            // clear the background (with black)
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            // set the vertex buffer to be drawn
            gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffer);
            // set the shader to use
            gl.useProgram(obj.shaderProgram);
            // connect up the shader parameters: vertex position and projection/model matrices
            gl.vertexAttribPointer(obj.shaderVertexPositionAttribute, obj.vertSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, obj.cBuffer);
            gl.vertexAttribPointer(obj.shaderVertexColorAttribute, 4, gl.FLOAT, false, 0, 0);

            gl.uniformMatrix4fv(obj.shaderProjectionMatrixUniform, false, projectionMatrix);
            gl.uniformMatrix4fv(obj.shaderModelViewMatrixUniform, false, modelViewMatrix);
            // draw the object
            gl.drawArrays(obj.primtype, 0, obj.nVerts);
        } else {
            gl.clearColor(5.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
    }

    window.onload = function () {
        var canvas = document.getElementById("webglcanvas");
        var gl = initWebGL(canvas);
        initViewport(gl, canvas);
        initMatrices();
        createSquare(gl);

        draw(gl, GlobalSquare);
        //Começa a renderização. ontimerCallback é a função onde a renderização ocorre
        var ontimerCallback = function () {
            draw(gl, GlobalSquare);
            setInterval(ontimerCallback, 500);
        }
        setInterval(ontimerCallback, 500);
    }

</script>
<head>
    <meta charset="utf-8"/>
    <title></title>
</head>
<body>
    <div class="content-grid mdl-grid mdl-layout mdl-shadow--2dp ">
        <div class="mdl-shadow--2dp mdl-cell--top mdl-cell--12-col">
            <strong>WebGL - Um exemplo prático</strong>
        </div>
        <div class="mdl-cell mdl-shadow--2dp mdl-cell--6-col">
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp mdl-cell--top">
                <strong>Cena</strong>
            </div>
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp mdl-cell--stretch">
                <canvas id="webglcanvas" width="400" height="400"></canvas>
            </div>
        </div>
        <div class="mdl-cell mdl-shadow--2dp mdl-cell--6-col">
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp mdl-cell--top">
                <strong>Controles</strong>
            </div>
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">Posição da câmera</div>
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">Foco da câmera</div>
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">View Up da câmera</div>
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">Tipo de Projeção</div>
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">Translação do objeto</div>
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">Rotação do objeto</div>
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">Pivot do objeto</div>
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">Posição da luz</div>
            <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">Intensidade da luz</div>
        </div>
        <div class="mdl-shadow--2dp mdl-cell--bottom mdl-cell--12-col">
            <div id="saida_fps" class="mdl-cell mdl-shadow--2dp">FPS: </div>
        </div>
    </div>
</body>

</html>