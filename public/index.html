<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<!--Começo do Material Design Lite-->
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.teal-red.min.css">
<script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
<!--Fim do Material Design Lite-->
<!-- Começo do jquery-->
<script
    src="http://code.jquery.com/jquery-3.2.1.min.js"
    integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
    crossorigin="anonymous"></script>
<!-- Fim do jquery-->
<!-- Começo da Biblioteca de matrizes para o webgl-->
<script src="gl-matrix.js"></script>
<!-- Fim da Biblioteca de matrizes para o webgl-->
<script type="text/javascript" src="opengl.js"></script>
<script type="text/javascript" src="shader.js"></script>
<script type="text/javascript">
    //O meu objeto
    var GlobalSquare = undefined;
    //O contexto opengl
    var gl = undefined;
    //As 3 matrizes importantes
    var projectionMatrix, modelMatrix, viewMatrix;
    var eye, focus, vUp;

    function initMatrices() {
        //Cria as matrix como identidades
        modelMatrix = mat4.create();
        viewMatrix = mat4.create();
        projectionMatrix = mat4.create();
        //a perspectiva
        mat4.perspective(projectionMatrix, 45.0, 1.0, 0.1, 100.0);
        mat4.lookAt(viewMatrix, eye, focus, vUp);

        mat4.translate(modelMatrix, modelMatrix, [0.0, 0.0, 0.0]);
    }
    // Create the vertex data for a square to be drawn
    function createSquare(gl) {
        //Pede o arquivo que define meu objeto. Isso é uma operação assincrona,
        //como todos os IOs em js
        var result = fetch('http://localhost:8080/testeObjeto.json')
            .then(response => {//Resolve ou rejeita a promessa de carga que foi feita
                if (response.status === 200 || response.status === 0) {
                    return Promise.resolve(response);
                } else {
                    return Promise.reject(new Error(response.statusText));
                }
            })
            .then(response => {//Resposta é um json pro próximo método.
                return response.json();
            })
            .then(function (data) {
                //Aqui eu já tenho o json
                var vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                var testeArr1 = new Float32Array(data.geometry);
                gl.bufferData(gl.ARRAY_BUFFER, testeArr1, gl.STATIC_DRAW);
                var colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                var testeArr2 = new Float32Array(data.color);
                gl.bufferData(gl.ARRAY_BUFFER, testeArr2, gl.STATIC_DRAW);
                //O shader é inicializado aqui.
                var shaderProgram = initShader(gl, vertexShaderSource, fragmentShaderSource);
                var square = {
                    buffer: vertexBuffer,
                    cBuffer: colorBuffer,
                    vertSize: data.vertexSize,
                    nVerts: (data.geometry.length/3),
                    primtype: gl.TRIANGLES,
                    shaderProgram: shaderProgram,
                    shaderVertexPositionAttribute: gl.getAttribLocation(shaderProgram, "vertexPos"),
                    shaderVertexColorAttribute: gl.getAttribLocation(shaderProgram, "vertexColor"),
                    shaderProjectionMatrixUniform: gl.getUniformLocation(shaderProgram, "projectionMatrix"),
                    shaderViewMatrixUniform: gl.getUniformLocation(shaderProgram, "viewMatrix"),
                    shaderModelMatrixUniform: gl.getUniformLocation(shaderProgram, "modelMatrix")
                };
                gl.enableVertexAttribArray(square.shaderVertexPositionAttribute);
                gl.enableVertexAttribArray(square.shaderVertexColorAttribute);
                square.pos = [0, 0, 0];
                square.rotation = [0, 1, 0, 0];
                GlobalSquare = square;
                UpdateTranslate();
                UpdateRotation();
                return square;
            })
            .catch(function (error) {
                    alert(error);
                }
            );
    }
    //function draw(gl, obj) {
    function draw() {
        const t0 = Date.now();
        if (GlobalSquare) {
            // clear the background (with black)
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            // set the vertex buffer to be drawn
            gl.bindBuffer(gl.ARRAY_BUFFER, GlobalSquare.buffer);
            // set the shader to use
            gl.useProgram(GlobalSquare.shaderProgram);
            // connect up the shader parameters: vertex position and projection/model matrices

            var objAxis = [GlobalSquare.rotation[0], GlobalSquare.rotation[1], GlobalSquare.rotation[2]];
            var objAngle = GlobalSquare.rotation[3];
            var objTrans = GlobalSquare.pos;
            var identityMatrix = mat4.create();
            modelMatrix = mat4.create();
            mat4.identity(identityMatrix);
            mat4.identity(modelMatrix);
            mat4.translate(modelMatrix, identityMatrix, objTrans);
            mat4.rotate(modelMatrix, modelMatrix, objAngle * 0.0174533, objAxis);

            gl.vertexAttribPointer(GlobalSquare.shaderVertexPositionAttribute, GlobalSquare.vertSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, GlobalSquare.cBuffer);
            gl.vertexAttribPointer(GlobalSquare.shaderVertexColorAttribute, 4, gl.FLOAT, false, 0, 0);
            gl.uniformMatrix4fv(GlobalSquare.shaderProjectionMatrixUniform, false, projectionMatrix);
            gl.uniformMatrix4fv(GlobalSquare.shaderViewMatrixUniform, false, viewMatrix);
            gl.uniformMatrix4fv(GlobalSquare.shaderModelMatrixUniform, false, modelMatrix);

            gl.drawArrays(GlobalSquare.primtype, 0, GlobalSquare.nVerts);

            //mat4.rotate(modelMatrix, modelMatrix, 0.01, [0.0, 1.0, 0.0]);
        } else {
            gl.clearColor(5.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
        const t = Date.now();
        const fps = t -t0;
        $("#saida_fps").text("dT da renderizacao = " + fps + "ms");
        
        requestAnimationFrame(draw);
    }
    window.onload = function () {
        //as propriedades da camera
        eye = [1.0, 1.0, -3.0];
        focus = [0.0, 0.0, 0.0];
        vUp = [0.0, 1.0, 0.0];
        var canvas = document.getElementById("webglcanvas");
        gl = initWebGL(canvas);

        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);

        initViewport(gl, canvas);
        initMatrices();
        createSquare(gl);
        UpdateCameraEdits();
        requestAnimationFrame(draw);
    }
    
    function UpdateCameraEdits() {
        $("#eyeX").val(eye[0]); $("#eyeY").val(eye[1]); $("#eyeZ").val(eye[2]);
        $("#focusX").val(focus[0]); $("#focusY").val(focus[1]); $("#focusZ").val(focus[2]);
        $("#vupX").val(vUp[0]); $("#vupY").val(vUp[1]); $("#vupZ").val(vUp[2]);
    }

    function UpdateRotation() {
        $("#rotAxisX").val(GlobalSquare.rotation[0]);
        $("#rotAxisY").val(GlobalSquare.rotation[1]);
        $("#rotAxisZ").val(GlobalSquare.rotation[2]);
        $("#rotAngle").val(GlobalSquare.rotation[3]);
    }

    function UpdateTranslate() {
        $("#transX").val(GlobalSquare.pos[0]);
        $("#transY").val(GlobalSquare.pos[1]);
        $("#transZ").val(GlobalSquare.pos[2]);
    }

    function SetProjecao() {
        let tipo = $("#cmbProjecao").val();
        if (tipo==="Perspectiva") {
            mat4.perspective(projectionMatrix, 45.0, 1.0, 0.1, 100.0);
        } else if (tipo === "Ortográfica") {
            mat4.ortho(projectionMatrix, -2, 2, -2, 2, 0.1, 25.0);
        }
    }

    function SetTranslate() {
        GlobalSquare.pos = [parseFloat($("#transX").val()), parseFloat($("#transY").val()), parseFloat($("#transZ").val())];
    }

    function SetRotate() {
        GlobalSquare.rotation = [parseFloat($("#rotAxisX").val()), parseFloat($("#rotAxisY").val()), parseFloat($("#rotAxisZ").val()), parseFloat($("#rotAngle").val())];
    }

    function SetViewMatrix() {
        eye = [ parseFloat($("#eyeX").val()), parseFloat($("#eyeY").val()), parseFloat($("#eyeZ").val())];
        focus = [ parseFloat($("#focusX").val()), parseFloat($("#focusY").val()), parseFloat($("#focusZ").val())];
        vUp = [ parseFloat($("#vupX").val()), parseFloat($("#vupY").val()), parseFloat($("#vupZ").val())];
        mat4.lookAt(viewMatrix, eye, focus, vUp);
    }
</script>
<head>
    <meta charset="utf-8"/>
    <title></title>
</head>
<body>
<div class="content-grid mdl-grid mdl-layout mdl-shadow--2dp ">
    <div class="mdl-shadow--2dp mdl-cell--top mdl-cell--12-col">
        <strong>WebGL - Um exemplo prático</strong>
    </div>
    <div class="mdl-cell mdl-shadow--2dp mdl-cell--6-col">
        <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp mdl-cell--top">
            <strong>Cena</strong>
        </div>
        <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp mdl-cell--stretch">
            <canvas id="webglcanvas" width="400" height="400"></canvas>
        </div>
    </div>
    <div class="mdl-cell mdl-shadow--2dp mdl-cell--6-col">
        <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp mdl-cell--top">
            <strong>Controles</strong>
        </div>
        <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">
            Posição da câmera
            <input type="text" id="eyeX" onchange="SetViewMatrix()"/>
            <input type="text" id="eyeY" onchange="SetViewMatrix()"/>
            <input type="text" id="eyeZ" onchange="SetViewMatrix()"/>
        </div>
        <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">Foco da câmera
            <input type="text" id="focusX" onchange="SetViewMatrix()"/>
            <input type="text" id="focusY" onchange="SetViewMatrix()"/>
            <input type="text" id="focusZ" onchange="SetViewMatrix()"/>
        </div>

        <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">
            View Up da câmea
            <input type="text" id="vupX" onchange="SetViewMatrix()"/>
            <input type="text" id="vupY" onchange="SetViewMatrix()"/>
            <input type="text" id="vupZ" onchange="SetViewMatrix()"/>
        </div>
        <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">
            Tipo de Projeção
            <select id="cmbProjecao" onchange="SetProjecao()">
                <option>Perspectiva</option>
                <option>Ortográfica</option>
            </select>
        </div>
        <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">
            Translação do objeto
            <input type="text" id="transX" onchange="SetTranslate()"/>
            <input type="text" id="transY" onchange="SetTranslate()" />
            <input type="text" id="transZ" onchange="SetTranslate()" />
        </div>
        <div class="mdl-cell mdl-cell--12-col mdl-shadow--2dp">
            Rotação do objeto
            <input type="text" id="rotAxisX" onchange="SetRotate()" />
            <input type="text" id="rotAxisY" onchange="SetRotate()" />
            <input type="text" id="rotAxisZ" onchange="SetRotate()" />
            <input type="text" id="rotAngle" onchange="SetRotate()" />
        </div>
    </div>
    <div class="mdl-shadow--2dp mdl-cell mdl-cell--12-col">
        <strong>Tarefas:</strong>
        <div class="mdl-shadow--2dp mdl-cell mdl-cell--12-col mdl-color--amber-100">
            1)Por o cubo funcionando - FEITO
        </div>
        <div class="mdl-shadow--2dp mdl-cell mdl-cell--12-col mdl-color--amber-100">
            2)Controlar a cena usando os controles na tela - FEITO
        </div>
        <div class="mdl-shadow--2dp mdl-cell mdl-cell--12-col">
            3)Texturas 
        </div>
        <div class="mdl-shadow--2dp mdl-cell mdl-cell--12-col">
            4)Iluminação
        </div>
        <div class="mdl-shadow--2dp mdl-cell mdl-cell--12-col">
            5)Textura3d
        </div>
        <div class="mdl-shadow--2dp mdl-cell mdl-cell--12-col">
            6)Blending
        </div>
        <div class="mdl-shadow--2dp mdl-cell mdl-cell--12-col">
            7)FBO
        </div>
        <div class="mdl-shadow--2dp mdl-cell mdl-cell--12-col">
            Aprendidas essas coisas a base o webgl será conhecida
        </div>

    </div>

    <div class="mdl-shadow--2dp mdl-cell--bottom mdl-cell--12-col">
        <div id="saida_fps" class="mdl-cell mdl-shadow--2dp">FPS: </div>
    </div>
</div>
</body>

</html>
